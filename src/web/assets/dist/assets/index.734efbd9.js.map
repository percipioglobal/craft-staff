{"version":3,"file":"index.734efbd9.js","sources":["../../../../../buildchain/node_modules/graphql/jsutils/isObjectLike.mjs","../../../../../buildchain/node_modules/graphql/jsutils/invariant.mjs","../../../../../buildchain/node_modules/graphql/language/location.mjs","../../../../../buildchain/node_modules/graphql/language/printLocation.mjs","../../../../../buildchain/node_modules/graphql/error/GraphQLError.mjs","../../../../../buildchain/node_modules/graphql/error/syntaxError.mjs","../../../../../buildchain/node_modules/graphql/language/directiveLocation.mjs","../../../../../buildchain/node_modules/graphql/language/tokenKind.mjs","../../../../../buildchain/node_modules/graphql/language/lexer.mjs","../../../../../buildchain/node_modules/graphql/language/parser.mjs","../../../../../buildchain/node_modules/graphql-tag/lib/index.js"],"sourcesContent":["/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport function isObjectLike(value) {\n  return typeof value == 'object' && value !== null;\n}\n","export function invariant(condition, message) {\n  const booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(\n      message != null ? message : 'Unexpected invariant triggered.',\n    );\n  }\n}\n","import { invariant } from '../jsutils/invariant.mjs';\nconst LineRegExp = /\\r\\n|[\\n\\r]/g;\n/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  let lastLineStart = 0;\n  let line = 1;\n\n  for (const match of source.body.matchAll(LineRegExp)) {\n    typeof match.index === 'number' || invariant(false);\n\n    if (match.index >= position) {\n      break;\n    }\n\n    lastLineStart = match.index + match[0].length;\n    line += 1;\n  }\n\n  return {\n    line,\n    column: position + 1 - lastLineStart,\n  };\n}\n","import { getLocation } from './location.mjs';\n\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\nexport function printLocation(location) {\n  return printSourceLocation(\n    location.source,\n    getLocation(location.source, location.start),\n  );\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  const firstLineColumnOffset = source.locationOffset.column - 1;\n  const body = ''.padStart(firstLineColumnOffset) + source.body;\n  const lineIndex = sourceLocation.line - 1;\n  const lineOffset = source.locationOffset.line - 1;\n  const lineNum = sourceLocation.line + lineOffset;\n  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  const columnNum = sourceLocation.column + columnOffset;\n  const locationStr = `${source.name}:${lineNum}:${columnNum}\\n`;\n  const lines = body.split(/\\r\\n|[\\n\\r]/g);\n  const locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    const subLineIndex = Math.floor(columnNum / 80);\n    const subLineColumnNum = columnNum % 80;\n    const subLines = [];\n\n    for (let i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return (\n      locationStr +\n      printPrefixedLines([\n        [`${lineNum} |`, subLines[0]],\n        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ['|', subLine]),\n        ['|', '^'.padStart(subLineColumnNum)],\n        ['|', subLines[subLineIndex + 1]],\n      ])\n    );\n  }\n\n  return (\n    locationStr +\n    printPrefixedLines([\n      // Lines specified like this: [\"prefix\", \"string\"],\n      [`${lineNum - 1} |`, lines[lineIndex - 1]],\n      [`${lineNum} |`, locationLine],\n      ['|', '^'.padStart(columnNum)],\n      [`${lineNum + 1} |`, lines[lineIndex + 1]],\n    ])\n  );\n}\n\nfunction printPrefixedLines(lines) {\n  const existingLines = lines.filter(([_, line]) => line !== undefined);\n  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));\n  return existingLines\n    .map(([prefix, line]) => prefix.padStart(padLen) + (line ? ' ' + line : ''))\n    .join('\\n');\n}\n","import { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { getLocation } from '../language/location.mjs';\nimport {\n  printLocation,\n  printSourceLocation,\n} from '../language/printLocation.mjs';\n\nfunction toNormalizedOptions(args) {\n  const firstArg = args[0];\n\n  if (firstArg == null || 'kind' in firstArg || 'length' in firstArg) {\n    return {\n      nodes: firstArg,\n      source: args[1],\n      positions: args[2],\n      path: args[3],\n      originalError: args[4],\n      extensions: args[5],\n    };\n  }\n\n  return firstArg;\n}\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport class GraphQLError extends Error {\n  /**\n   * An array of `{ line, column }` locations within the source GraphQL document\n   * which correspond to this error.\n   *\n   * Errors during validation often contain multiple locations, for example to\n   * point out two things with the same name. Errors during execution include a\n   * single location, the field which produced the error.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array describing the JSON-path into the execution response which\n   * corresponds to this error. Only included for errors during execution.\n   *\n   * Enumerable, and appears in the result of JSON.stringify().\n   */\n\n  /**\n   * An array of GraphQL AST Nodes corresponding to this error.\n   */\n\n  /**\n   * The source GraphQL document for the first location of this error.\n   *\n   * Note that if this Error represents more than one node, the source may not\n   * represent nodes after the first node.\n   */\n\n  /**\n   * An array of character offsets within the source GraphQL document\n   * which correspond to this error.\n   */\n\n  /**\n   * The original error thrown from a field resolver during execution.\n   */\n\n  /**\n   * Extension fields to add to the formatted error.\n   */\n\n  /**\n   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.\n   */\n  constructor(message, ...rawArgs) {\n    var _this$nodes, _nodeLocations$, _ref;\n\n    const { nodes, source, positions, path, originalError, extensions } =\n      toNormalizedOptions(rawArgs);\n    super(message);\n    this.name = 'GraphQLError';\n    this.path = path !== null && path !== void 0 ? path : undefined;\n    this.originalError =\n      originalError !== null && originalError !== void 0\n        ? originalError\n        : undefined; // Compute list of blame nodes.\n\n    this.nodes = undefinedIfEmpty(\n      Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined,\n    );\n    const nodeLocations = undefinedIfEmpty(\n      (_this$nodes = this.nodes) === null || _this$nodes === void 0\n        ? void 0\n        : _this$nodes.map((node) => node.loc).filter((loc) => loc != null),\n    ); // Compute locations in the source for the given nodes/positions.\n\n    this.source =\n      source !== null && source !== void 0\n        ? source\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : (_nodeLocations$ = nodeLocations[0]) === null ||\n          _nodeLocations$ === void 0\n        ? void 0\n        : _nodeLocations$.source;\n    this.positions =\n      positions !== null && positions !== void 0\n        ? positions\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => loc.start);\n    this.locations =\n      positions && source\n        ? positions.map((pos) => getLocation(source, pos))\n        : nodeLocations === null || nodeLocations === void 0\n        ? void 0\n        : nodeLocations.map((loc) => getLocation(loc.source, loc.start));\n    const originalExtensions = isObjectLike(\n      originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions,\n    )\n      ? originalError === null || originalError === void 0\n        ? void 0\n        : originalError.extensions\n      : undefined;\n    this.extensions =\n      (_ref =\n        extensions !== null && extensions !== void 0\n          ? extensions\n          : originalExtensions) !== null && _ref !== void 0\n        ? _ref\n        : Object.create(null); // Only properties prescribed by the spec should be enumerable.\n    // Keep the rest as non-enumerable.\n\n    Object.defineProperties(this, {\n      message: {\n        writable: true,\n        enumerable: true,\n      },\n      name: {\n        enumerable: false,\n      },\n      nodes: {\n        enumerable: false,\n      },\n      source: {\n        enumerable: false,\n      },\n      positions: {\n        enumerable: false,\n      },\n      originalError: {\n        enumerable: false,\n      },\n    }); // Include (non-enumerable) stack trace.\n\n    /* c8 ignore start */\n    // FIXME: https://github.com/graphql/graphql-js/issues/2317\n\n    if (\n      originalError !== null &&\n      originalError !== void 0 &&\n      originalError.stack\n    ) {\n      Object.defineProperty(this, 'stack', {\n        value: originalError.stack,\n        writable: true,\n        configurable: true,\n      });\n    } else if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, GraphQLError);\n    } else {\n      Object.defineProperty(this, 'stack', {\n        value: Error().stack,\n        writable: true,\n        configurable: true,\n      });\n    }\n    /* c8 ignore stop */\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLError';\n  }\n\n  toString() {\n    let output = this.message;\n\n    if (this.nodes) {\n      for (const node of this.nodes) {\n        if (node.loc) {\n          output += '\\n\\n' + printLocation(node.loc);\n        }\n      }\n    } else if (this.source && this.locations) {\n      for (const location of this.locations) {\n        output += '\\n\\n' + printSourceLocation(this.source, location);\n      }\n    }\n\n    return output;\n  }\n\n  toJSON() {\n    const formattedError = {\n      message: this.message,\n    };\n\n    if (this.locations != null) {\n      formattedError.locations = this.locations;\n    }\n\n    if (this.path != null) {\n      formattedError.path = this.path;\n    }\n\n    if (this.extensions != null && Object.keys(this.extensions).length > 0) {\n      formattedError.extensions = this.extensions;\n    }\n\n    return formattedError;\n  }\n}\n\nfunction undefinedIfEmpty(array) {\n  return array === undefined || array.length === 0 ? undefined : array;\n}\n/**\n * See: https://spec.graphql.org/draft/#sec-Errors\n */\n\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n *\n * @deprecated Please use `error.toString` instead. Will be removed in v17\n */\nexport function printError(error) {\n  return error.toString();\n}\n/**\n * Given a GraphQLError, format it according to the rules described by the\n * Response Format, Errors section of the GraphQL Specification.\n *\n * @deprecated Please use `error.toJSON` instead. Will be removed in v17\n */\n\nexport function formatError(error) {\n  return error.toJSON();\n}\n","import { GraphQLError } from './GraphQLError.mjs';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(`Syntax Error: ${description}`, {\n    source,\n    positions: [position],\n  });\n}\n","/**\n * The set of allowed directive location values.\n */\nexport let DirectiveLocation;\n/**\n * The enum type representing the directive location values.\n *\n * @deprecated Please use `DirectiveLocation`. Will be remove in v17.\n */\n\n(function (DirectiveLocation) {\n  DirectiveLocation['QUERY'] = 'QUERY';\n  DirectiveLocation['MUTATION'] = 'MUTATION';\n  DirectiveLocation['SUBSCRIPTION'] = 'SUBSCRIPTION';\n  DirectiveLocation['FIELD'] = 'FIELD';\n  DirectiveLocation['FRAGMENT_DEFINITION'] = 'FRAGMENT_DEFINITION';\n  DirectiveLocation['FRAGMENT_SPREAD'] = 'FRAGMENT_SPREAD';\n  DirectiveLocation['INLINE_FRAGMENT'] = 'INLINE_FRAGMENT';\n  DirectiveLocation['VARIABLE_DEFINITION'] = 'VARIABLE_DEFINITION';\n  DirectiveLocation['SCHEMA'] = 'SCHEMA';\n  DirectiveLocation['SCALAR'] = 'SCALAR';\n  DirectiveLocation['OBJECT'] = 'OBJECT';\n  DirectiveLocation['FIELD_DEFINITION'] = 'FIELD_DEFINITION';\n  DirectiveLocation['ARGUMENT_DEFINITION'] = 'ARGUMENT_DEFINITION';\n  DirectiveLocation['INTERFACE'] = 'INTERFACE';\n  DirectiveLocation['UNION'] = 'UNION';\n  DirectiveLocation['ENUM'] = 'ENUM';\n  DirectiveLocation['ENUM_VALUE'] = 'ENUM_VALUE';\n  DirectiveLocation['INPUT_OBJECT'] = 'INPUT_OBJECT';\n  DirectiveLocation['INPUT_FIELD_DEFINITION'] = 'INPUT_FIELD_DEFINITION';\n})(DirectiveLocation || (DirectiveLocation = {}));\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport let TokenKind;\n/**\n * The enum type representing the token kinds values.\n *\n * @deprecated Please use `TokenKind`. Will be remove in v17.\n */\n\n(function (TokenKind) {\n  TokenKind['SOF'] = '<SOF>';\n  TokenKind['EOF'] = '<EOF>';\n  TokenKind['BANG'] = '!';\n  TokenKind['DOLLAR'] = '$';\n  TokenKind['AMP'] = '&';\n  TokenKind['PAREN_L'] = '(';\n  TokenKind['PAREN_R'] = ')';\n  TokenKind['SPREAD'] = '...';\n  TokenKind['COLON'] = ':';\n  TokenKind['EQUALS'] = '=';\n  TokenKind['AT'] = '@';\n  TokenKind['BRACKET_L'] = '[';\n  TokenKind['BRACKET_R'] = ']';\n  TokenKind['BRACE_L'] = '{';\n  TokenKind['PIPE'] = '|';\n  TokenKind['BRACE_R'] = '}';\n  TokenKind['NAME'] = 'Name';\n  TokenKind['INT'] = 'Int';\n  TokenKind['FLOAT'] = 'Float';\n  TokenKind['STRING'] = 'String';\n  TokenKind['BLOCK_STRING'] = 'BlockString';\n  TokenKind['COMMENT'] = 'Comment';\n})(TokenKind || (TokenKind = {}));\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport class Lexer {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n  advance() {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n}\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\n\nfunction isUnicodeScalarValue(code) {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\n\nfunction isSupplementaryCodePoint(body, location) {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\n * Create a token with line and column location information.\n */\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (\n          body.charCodeAt(position + 1) === 0x002e &&\n          body.charCodeAt(position + 2) === 0x002e\n        ) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n/**\n * Returns the new position in the source after reading one or more digits.\n */\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size,\n      };\n    } // Append this hex digit to the code point.\n\n    point = (point << 4) | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6,\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12,\n        };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n    ? code - 0x0037\n    : code >= 0x0061 && code <= 0x0066 // a-f\n    ? code - 0x0057\n    : -1;\n}\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2,\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2,\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2,\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2,\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2,\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2,\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2,\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2,\n      };\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3, // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n","import { syntaxError } from '../error/syntaxError.mjs';\nimport { Location, OperationTypeNode } from './ast.mjs';\nimport { DirectiveLocation } from './directiveLocation.mjs';\nimport { Kind } from './kinds.mjs';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.mjs';\nimport { isSource, Source } from './source.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\n\nexport function parseConstValue(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport class Parser {\n  constructor(source, options) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n  parseName() {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n\n  parseDocument() {\n    return this.node(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n\n  parseDefinition() {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } // Many definitions begin with a description and require a lookahead.\n\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n\n  parseOperationDefinition() {\n    const start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    const operation = this.parseOperationType();\n    let name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return this.node(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n\n  parseOperationType() {\n    const operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n\n  parseVariableDefinitions() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n\n  parseVariableDefinition() {\n    return this.node(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n  /**\n   * Variable : $ Name\n   */\n\n  parseVariable() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n\n  parseSelectionSet() {\n    return this.node(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n\n  parseSelection() {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n\n  parseField() {\n    const start = this._lexer.token;\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n\n  parseArguments(isConst) {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n\n  parseArgument(isConst = false) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument() {\n    return this.parseArgument(true);\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n\n  parseFragment() {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n\n  parseFragmentDefinition() {\n    var _this$_options;\n\n    const start = this._lexer.token;\n    this.expectKeyword('fragment'); // Legacy support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (\n      ((_this$_options = this._options) === null || _this$_options === void 0\n        ? void 0\n        : _this$_options.allowLegacyFragmentVariables) === true\n    ) {\n      return this.node(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n\n    return this.node(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n\n  parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseValueLiteral(isConst) {\n    const token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return this.node(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n\n          case 'false':\n            return this.node(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n\n          case 'null':\n            return this.node(token, {\n              kind: Kind.NULL,\n            });\n\n          default:\n            return this.node(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n\n        return this.parseVariable();\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral() {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral() {\n    const token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return this.node(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n\n  parseList(isConst) {\n    const item = () => this.parseValueLiteral(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n\n  parseObject(isConst) {\n    const item = () => this.parseObjectField(isConst);\n\n    return this.node(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n\n  parseObjectField(isConst) {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n\n  parseDirectives(isConst) {\n    const directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n\n  parseConstDirectives() {\n    return this.parseDirectives(true);\n  }\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n\n  parseDirective(isConst) {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n\n  parseTypeReference() {\n    const start = this._lexer.token;\n    let type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n\n  parseNamedType() {\n    return this.node(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  } // Implements the parsing rules in the Type Definition section.\n\n  peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n\n  parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n\n  parseSchemaDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n\n  parseOperationTypeDefinition() {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n\n  parseScalarTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n\n  parseObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n\n  parseImplementsInterfaces() {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n\n  parseFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n\n  parseFieldDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n\n  parseArgumentDefs() {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n\n  parseInputValueDef() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n\n  parseInterfaceTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n\n  parseUnionTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n\n  parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n\n  parseEnumTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n\n  parseEnumValuesDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n\n  parseEnumValueDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n\n  parseEnumValueName() {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n\n    return this.parseName();\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n\n  parseInputObjectTypeDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n\n  parseInputFieldsDefinition() {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n\n  parseTypeSystemExtension() {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n\n  parseSchemaExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n\n  parseScalarTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n\n  parseObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n\n  parseInterfaceTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n\n  parseUnionTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n\n  parseEnumTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n\n  parseInputObjectTypeExtension() {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return this.node(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n\n  parseDirectiveDefinition() {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n\n  parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n\n  parseDirectiveLocation() {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n\n  node(startToken, node) {\n    var _this$_options2;\n\n    if (\n      ((_this$_options2 = this._options) === null || _this$_options2 === void 0\n        ? void 0\n        : _this$_options2.noLocation) !== true\n    ) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n\n    return node;\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n\n  peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalToken(kind) {\n    const token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n\n  expectKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n\n  expectOptionalKeyword(value) {\n    const token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n\n  unexpected(atToken) {\n    const token =\n      atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n\n  many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n\n  delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    const nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  }\n}\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n","import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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"}